# 153 Maximum Subarray
[leet code链接](https://leetcode-cn.com/problems/maximum-subarray/)

这道题的题意为，给定一个数组，求这个数组和最大的连续子数组

## DP解法

构造递归式，假设f[i] 为以i结尾的子数组的最大连续子数组值，
则f[i] = max(f[i -1] + nums[i], nums[i] ), 时间复杂度O(n), 空间复杂度O(n).

## 分治解法
### 注意这里只实现了O(nlogn)的版本，可以通过存储lSum与rSum来实现O(n)的版本
首先思考如何划分子问题，对于一个区间[l, r], 取m = l + r / 2划分
当区间长度为1使，开始回升。
回升时要思考两个问题
- 每个区间维护哪些信息
- 如何合并信息

对于一个区间 [l, r][l,r]，我们可以维护四个量：

- lSum 表示 [l, r][l,r] 内以 ll 为左端点的最大子段和
- rSum 表示 [l, r][l,r] 内以 rr 为右端点的最大子段和
- mSum 表示 [l, r][l,r] 内的最大子段和
- iSum 表示 [l, r][l,r] 的区间和

对于合并：
- 首先最好维护的是 iSum，区间 [l, r][l,r] 的 iSum 就等于「左子区间」
的 iSum 加上「右子区间」的 iSum。
- 对于 [l, r][l,r] 的 lSum，存在两种可能，
它要么等于「左子区间」的 lSum，
要么等于「左子区间」的 iSum加上「右子区间」的 lSum，二者取大。
- 对于 [l, r][l,r] 的 rSum，同理，
它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，
二者取大。
- 当计算好上面的三个量之后，就很好计算 [l, r][l,r] 的 mSum 了。
我们可以考虑 [l, r][l,r] 的 mSum 对应的区间是否跨越 mm——它可能不跨越 mm，
也就是说 [l, r][l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；
它也可能跨越 mm，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。


#题外话
「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，
运行的时间略长，
空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？

对于这道题而言，确实是如此的。但是仔细观察「方法二」，
它不仅可以解决区间 [0, n - 1][0,n−1]，还可以用于解决任意的子区间 [l, r][l,r] 的问题。
如果我们把 [0, n - 1][0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，
即建成一颗真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，
我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 
的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。
这棵树就是上文提及的一种神奇的数据结构——线段树。





