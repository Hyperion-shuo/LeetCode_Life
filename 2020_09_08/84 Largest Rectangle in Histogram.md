# 84 Largest Rectangle in Histogram

**使用单调栈**

**思路**

如果我们枚举「高」，我们可以使用一重循环枚举某一根柱子，将其固定为矩形的高度 h。
随后我们从这跟柱子开始向两侧延伸，直到遇到高度小于 h 的柱子，就确定了矩形的左右边界。
如果左右边界之间的宽度为 ww，那么对应的面积为 w * h。


我们归纳一下枚举「高」的方法：

- 首先我们枚举某一根柱子 i作为高 h=heights[i]；

- 随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 h。换句话说，
我们需要找到左右两侧最近的高度小于 h 的柱子，这样这两根柱子之间（不包括其本身）
的所有柱子高度均不小于 h，并且就是 i 能够扩展到的最远范围。


对于两根柱子 j_0以及 j_1，如果 j_0 < j_1并且h[0] < h[1],
那么对于任意的在它们之后出现的柱子 i（ j_1 < i ), 
j0 一定不会是 i 左侧且最近的小于其高度的柱子.


即如果j0在j1左侧且j0 > j1 ,则j1会挡住j0。

因此可以维护一个数据结构单调栈 j1 < j2 < j3 < ... < i < s... < jn,
且h[j1] < h[j2] < h[j3] <  ... < h[i] < h[s]... < h[jn].
当遇到当前柱子 i 时，弹出大于i的柱子s到n，左侧的即是左边第一个高度小于h的柱子的下标

- 若栈为空则柱子左侧没有元素比他小，可以单独判断一次栈是否为空，或者在-1位置设置一个高度
为 -inf的哨兵

同理维护一个从右向左的结构，两者相减就得到了矩形宽度w。
 



